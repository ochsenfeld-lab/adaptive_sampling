<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.10.0" />
<title>adaptive_sampling.colvars.colvars API documentation</title>
<meta name="description" content="" />
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/sanitize.min.css" integrity="sha256-PK9q560IAAa6WVRRh76LtCaI8pjTJ2z11v0miyNNjrs=" crossorigin>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/typography.min.css" integrity="sha256-7l/o7C8jubJiy74VsKTidCy1yBkRtiUGbVkYBylBqUg=" crossorigin>
<link rel="stylesheet preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/styles/github.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/highlight.min.js" integrity="sha256-Uv3H6lx7dJmRfRvH8TH6kJD1TSK1aFcwgx+mdg3epi8=" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting())</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>adaptive_sampling.colvars.colvars</code></h1>
</header>
<section id="section-intro">
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">import sys
import torch
import numpy as np

from typing import Union, Tuple
from ..interface.sampling_data import MDInterface
from ..units import *


class CV:
    &#34;&#34;&#34;Class for Collective Variables

    Automatic computation of gradients is implemented using the autograd differentiation engine of Torch

    Args:
        the_mol: Molecule Object containing masses (natoms) and coords (3*natoms)
        requires_grad: if True, partial derivatives of CVs with respect
                                to atom coordinats are computed
                                and saved to self.gradient
    &#34;&#34;&#34;

    def __init__(self, the_mol: MDInterface, requires_grad: bool = False):

        self.the_mol = the_mol
        self.requires_grad = requires_grad

        md_state = self.the_mol.get_sampling_data()

        self.mass = torch.from_numpy(md_state.mass)
        self.coords = torch.from_numpy(md_state.coords.ravel())
        self.natoms = len(self.mass)
        self.requires_grad = requires_grad
        self.gradient = None
        self.cv = None
        self.type = &#34;default&#34;

    def update_coords(self):
        &#34;&#34;&#34;The coords tensor and ndarray share the same memory.
        Modifications to the tensor will be reflected in the ndarray and vice versa!&#34;&#34;&#34;
        self.coords = torch.from_numpy(self.the_mol.get_sampling_data().coords.ravel())
        self.coords = self.coords.float()
        self.coords.requires_grad = self.requires_grad

    @staticmethod
    def _partial_derivative(
        f: torch.tensor, *args: Tuple[torch.tensor]
    ) -&gt; Tuple[torch.tensor]:
        &#34;&#34;&#34;get partial derivative of arbitrary function from torch.autograd
    
        Args:
            f (torch.tensor): function f(*args) to differentiate
            *args (torch.tensor): variables of f for which derivative is computed
    
        Returns:
            partial_derivatives (Tuple[torch.tensor]): derivatives of f with respect to args
        &#34;&#34;&#34;
        return torch.autograd.grad(f, *args, allow_unused=True)

    def _get_com(self, atoms: Union[int, list]) -&gt; Tuple[torch.tensor, float]:
        &#34;&#34;&#34;get center of mass (com) of group of atoms
        if self.require_grad = True partial derivative with respect to com can be calculated using torch.autograd.grad

        Args:
            atoms (Union[int, list]): atom index or list of atom indices

        Returns:
            com (torch.tensor): Center of Mass
            m_tot(float): Total mass of involved atoms
        &#34;&#34;&#34;
        if hasattr(atoms, &#34;__len__&#34;):
            # compute center of mass for group of atoms
            com = torch.zeros(3, dtype=torch.float)
            for a in atoms:
                a = int(a)
                com += self.coords[3 * a] * self.mass[a]
                com += self.coords[3 * a + 1] * self.mass[a]
                com += self.coords[3 * a + 2] * self.mass[a]

            m_tot = self.mass[atoms].sum()
            com /= m_tot

        else:
            # only one atom
            atom = int(atoms)
            m_tot = self.mass[atom]
            com = torch.tensor(
                [
                    self.coords[3 * atom],
                    self.coords[3 * atom + 1],
                    self.coords[3 * atom + 2],
                ]
            )
        com = com.float()
        com.requires_grad = self.requires_grad

        return com, m_tot

    def _get_atom_weights(
        self, mass_group: float, atoms: Union[int, list]
    ) -&gt; torch.tensor:
        &#34;&#34;&#34;get mass weights of atoms for gradient of group of atoms

        Args:
            mass_group (float): sum of mass of atoms
            atoms (Union[int, list]): atom index or list of atom indices

        Returns:
            coords (torch.tensor): 3*3N array of mass weights of atoms
        &#34;&#34;&#34;
        coords = torch.zeros((3, 3 * self.natoms))
        if hasattr(atoms, &#34;__len__&#34;):
            for a in atoms:
                a = int(a)
                coords[0, 3 * a] = self.mass[a] / mass_group
                coords[1, 3 * a + 1] = self.mass[a] / mass_group
                coords[2, 3 * a + 2] = self.mass[a] / mass_group
        else:
            atoms = int(atoms)
            coords[0, 3 * atoms] = 1.0
            coords[1, 3 * atoms + 1] = 1.0
            coords[2, 3 * atoms + 2] = 1.0

        return coords

    def x(self) -&gt; float:
        &#34;&#34;&#34;use x axis as cv for numerical examples&#34;&#34;&#34;
        self.update_coords()
        if self.requires_grad:
            self.gradient = np.array([1.0, 0.0])
        self.cv = self.coords[0]
        return self.cv

    def y(self) -&gt; float:
        &#34;&#34;&#34;use y axis as cv for numerical examples&#34;&#34;&#34;
        self.update_coords()
        if self.requires_grad:
            self.gradient = np.array([0.0, 1.0])
        self.cv = self.coords[1]
        return self.cv

    def distance(self, cv_def: list) -&gt; float:
        &#34;&#34;&#34;distance between two mass centers in range(0, inf)

        Args:
            cv_def (list):
                distance beteen atoms: [ind0, ind1]
                distance between mass centers: [[ind00, ind01, ...], [ind10, ind11, ...]]

        Returns:
            cv (float): computed distance
        &#34;&#34;&#34;
        if len(cv_def) != 2:
            raise ValueError(
                &#34;CV ERROR: Invalid number of centers in definition of distance!&#34;
            )

        self.update_coords()

        (p1, m0) = self._get_com(cv_def[0])
        (p2, m1) = self._get_com(cv_def[1])

        # get distance
        r12 = p2 - p1
        self.cv = torch.linalg.norm(r12, dtype=torch.float)

        # get forces
        if self.requires_grad:
            # @AH: why don&#39;t you do? Does this not work?
            #            self.gradient = self.partial_derivative(self.cv, self.coords)
            atom_grads = self._partial_derivative(self.cv, (p1, p2))
            self.gradient = torch.matmul(
                atom_grads[0], self._get_atom_weights(m0, cv_def[0])
            )
            self.gradient += torch.matmul(
                atom_grads[1], self._get_atom_weights(m1, cv_def[1])
            )
            self.gradient = self.gradient.numpy()
        
        # AH: this returns (None,), I don&#39;t know why.
        #       self.gradient = torch.autograd.grad(self.cv, self.coords, allow_unused=True)

        return float(self.cv)

    def angle(self, cv_def: list) -&gt; float:
        &#34;&#34;&#34;get angle between three mass centers in range(-pi,pi)

        Args:
            cv_def (list):
                angle between two atoms: [ind0, ind1, ind3]
                angle between centers of mass: [[ind00, ind01, ...], [ind10, ind11, ...], [ind20, ind21, ...]]

        Returns:
            cv (float): computed angle
        &#34;&#34;&#34;
        if len(cv_def) != 3:
            raise ValueError(
                &#34;CV ERROR: Invalid number of centers in definition of angle!&#34;
            )

        self.update_coords()

        (p1, m0) = self._get_com(cv_def[0])
        (p2, m1) = self._get_com(cv_def[1])
        (p3, m2) = self._get_com(cv_def[2])

        # get angle
        q12 = p1 - p2
        q23 = p2 - p3

        q12_n = torch.linalg.norm(q12)
        q23_n = torch.linalg.norm(q23)

        q12_u = q12 / q12_n
        q23_u = q23 / q23_n

        self.cv = torch.arccos(torch.dot(-q12_u, q23_u))

        # get forces
        if self.requires_grad:
            atom_grads = self._partial_derivative(self.cv, (p1, p2, p3))
            self.gradient = torch.matmul(
                atom_grads[0], self._get_atom_weights(m0, cv_def[0])
            )
            self.gradient += torch.matmul(
                atom_grads[1], self._get_atom_weights(m1, cv_def[1])
            )
            self.gradient += torch.matmul(
                atom_grads[2], self._get_atom_weights(m2, cv_def[2])
            )
            self.gradient = self.gradient.numpy()

        return float(self.cv)

    def torsion(self, cv_def: list) -&gt; float:
        &#34;&#34;&#34;torsion angle between four mass centers in range(-pi,pi)

        Args:
            cv_def (list):
                dihedral between atoms: [ind0, ind1, ind2, ind3]
                dihedral between center of mass: [[ind00, ind01, ...],
                                                  [ind10, ind11, ...],
                                                  [ind20, ind21, ...],
                                                  [ind30, ind 31, ...]]

        Returns:
            cv (float): computed torsional angle
        &#34;&#34;&#34;
        if len(cv_def) != 4:
            raise ValueError(
                &#34;CV ERROR: Invalid number of centers in definition of dihedral!&#34;
            )

        self.update_coords()

        (p1, m1) = self._get_com(cv_def[0])
        (p2, m2) = self._get_com(cv_def[1])
        (p3, m3) = self._get_com(cv_def[2])
        (p4, m4) = self._get_com(cv_def[3])

        # get dihedral
        q12 = p2 - p1
        q23 = p3 - p2
        q34 = p4 - p3

        q23_u = q23 / torch.linalg.norm(q23)

        n1 = -q12 - torch.dot(-q12, q23_u) * q23_u
        n2 = q34 - torch.dot(q34, q23_u) * q23_u

        self.cv = torch.atan2(torch.dot(torch.cross(q23_u, n1), n2), torch.dot(n1, n2))

        # get forces
        if self.requires_grad:
            atom_grads = self._partial_derivative(self.cv, (p1, p2, p3, p4))
            self.gradient = torch.matmul(
                atom_grads[0], self._get_atom_weights(m1, cv_def[0])
            )
            self.gradient += torch.matmul(
                atom_grads[1], self._get_atom_weights(m2, cv_def[1])
            )
            self.gradient += torch.matmul(
                atom_grads[2], self._get_atom_weights(m3, cv_def[2])
            )
            self.gradient += torch.matmul(
                atom_grads[3], self._get_atom_weights(m4, cv_def[3])
            )
            self.gradient = self.gradient.numpy()

        return float(self.cv)

    def linear_combination(self, cv_def: list) -&gt; float:
        &#34;&#34;&#34;linear combination of distances, angles or dihedrals between atoms or groups of atoms

        Args:
            cv_dev (list):
                list of distances, angle or torsions with prefactors: [[fac0, [ind00, ind01]],
                                                                       [fac1, [ind10, ind11, ind12]],
                                                                       [fac2, [ind20, ind21, ind22, ind23]],
                                                                       ...]

        Returns:
            cv (float): linear combination of distances/angles/dihedrals
        &#34;&#34;&#34;
        self.update_coords()

        self.lc_contribs = []
        gradient = np.zeros(3 * self.natoms, dtype=float)

        for cv in cv_def:

            if len(cv[1]) == 2:
                x = self.distance(cv[1])

            elif len(cv[1]) == 3:
                x = self.angle(cv[1])

            elif len(cv[1]) == 4:
                x = self.torsion(cv[1])

            else:
                raise ValueError(
                    &#34;CV ERROR: Invalid number of centers in definition of linear combination!&#34;
                )

            self.lc_contribs.append(cv[0] * x)
            if self.requires_grad:
                gradient += cv[0] * self.gradient

        if self.requires_grad:
            self.gradient = gradient

        self.cv = np.asarray(self.lc_contribs).sum()
        return float(self.cv)

    def write_lc_traj(self, out: str = &#34;lc_traj.dat&#34;):
        &#34;&#34;&#34;write out seperate trajectory for contributions to linear combination

        Args:
            our (str): name of output file
        &#34;&#34;&#34;
        with open(out, &#34;a&#34;) as traj_out:
            for lc in self.lc_contribs:
                traj_out.write(&#34;%14.6f\t&#34; % lc)
            traj_out.write(&#34;\n&#34;)

    def coordination_number(self, cv_def: list, r_0: float = 3.0) -&gt; float:
        &#34;&#34;&#34;coordination number between two mass centers in range(0, inf) mapped to range(1,0)

        Args:
            cv_def (list):
                distorted distance beteen atoms: [ind0, ind1]
                distorted distance between mass centers: [[ind00, ind01, ...],
                                                          [ind10, ind11, ...]]

        Returns:
            distorted distance (float): computed distance
        &#34;&#34;&#34;
        self.update_coords()

        if len(cv_def) != 2:
            raise ValueError(
                &#34;CV ERROR: Invalid number of centers in definition of distance!&#34;
            )

        r_0 /= BOHR_to_ANGSTROM

        (p1, m0) = self._get_com(cv_def[0])
        (p2, m1) = self._get_com(cv_def[1])

        # get distance
        r12 = p2 - p1
        d = torch.linalg.norm(r12, dtype=torch.float) / r_0

        self.cv = (1.0 - torch.pow(d, 6)) / (1.0 - torch.pow(d, 12))

        # get forces
        if self.requires_grad:
            atom_grads = self._partial_derivative(self.cv, (p1, p2))
            self.gradient = torch.matmul(
                atom_grads[0], self._get_atom_weights(m0, cv_def[0])
            )
            self.gradient += torch.matmul(
                atom_grads[1], self._get_atom_weights(m1, cv_def[1])
            )
            self.gradient = self.gradient.numpy()

        return float(self.cv)

    def custom_lin_comb(self, cvs: list, **kwargs) -&gt; float:
        &#34;&#34;&#34;custom linear combination of arbitrary functions&#34;&#34;&#34;
        self.update_coords()
        cv = 0.0
        gradient = np.zeros(len(self.gradient))
        for _, cv_def in enumerate(cvs):
            z, dz = self.get_cv(cv_def[0], cv_def[2])
            cv += cv_def[1] * z
            gradient += cv_def[1] * dz

        self.cv = cv
        self.gradient = gradient
        return float(cv)

    def get_cv(self, cv, atoms, **kwargs) -&gt; Tuple[float, np.ndarray]:
        &#34;&#34;&#34;get state of collective variable

        Returns:
           xi (float): value of collective variable
           gradient (np.ndarray) : gradient of collective variable
        &#34;&#34;&#34;
        if cv.lower() == &#34;x&#34;:
            xi = self.x()
            self.type = &#34;2d&#34;
        elif cv.lower() == &#34;y&#34;:
            xi = self.y()
            self.type = &#34;2d&#34;
        elif cv.lower() == &#34;distance&#34;:
            xi = self.distance(atoms)
            self.type = &#34;distance&#34;
        elif cv.lower() == &#34;angle&#34;:
            xi = self.angle(atoms)
            self.type = &#34;angle&#34;
        elif cv.lower() == &#34;torsion&#34;:
            xi = self.torsion(atoms)
            self.type = &#34;angle&#34;
        elif cv.lower() == &#34;lin_comb_dists&#34;:
            xi = self.linear_combination(atoms)
            self.type = &#34;distance&#34;
        elif cv.lower() == &#34;lin_comb_angles&#34;:
            xi = self.linear_combination(atoms)
            self.type = &#34;angle&#34;
        elif cv.lower() == &#34;linear_combination&#34;:
            xi = self.linear_combination(atoms)
            self.type = None
        elif cv.lower() == &#34;coordination_number&#34;:
            xi = self.coordination_number(atoms)
            self.type = None
        elif cv.lower() == &#34;lin_comb_custom&#34;:
            xi = self.custom_lin_comb(atoms)
            self.type = None
        else:
            print(&#34; &gt;&gt;&gt; Error in CV: Unknown coordinate&#34;)
            sys.exit(1)

        if self.requires_grad:
            return xi, self.gradient
        else:
            return xi</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="adaptive_sampling.colvars.colvars.CV"><code class="flex name class">
<span>class <span class="ident">CV</span></span>
<span>(</span><span>the_mol: <a title="adaptive_sampling.interface.sampling_data.MDInterface" href="../interface/sampling_data.html#adaptive_sampling.interface.sampling_data.MDInterface">MDInterface</a>, requires_grad: bool = False)</span>
</code></dt>
<dd>
<div class="desc"><p>Class for Collective Variables</p>
<p>Automatic computation of gradients is implemented using the autograd differentiation engine of Torch</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>the_mol</code></strong></dt>
<dd>Molecule Object containing masses (natoms) and coords (3*natoms)</dd>
<dt><strong><code>requires_grad</code></strong></dt>
<dd>if True, partial derivatives of CVs with respect
to atom coordinats are computed
and saved to self.gradient</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class CV:
    &#34;&#34;&#34;Class for Collective Variables

    Automatic computation of gradients is implemented using the autograd differentiation engine of Torch

    Args:
        the_mol: Molecule Object containing masses (natoms) and coords (3*natoms)
        requires_grad: if True, partial derivatives of CVs with respect
                                to atom coordinats are computed
                                and saved to self.gradient
    &#34;&#34;&#34;

    def __init__(self, the_mol: MDInterface, requires_grad: bool = False):

        self.the_mol = the_mol
        self.requires_grad = requires_grad

        md_state = self.the_mol.get_sampling_data()

        self.mass = torch.from_numpy(md_state.mass)
        self.coords = torch.from_numpy(md_state.coords.ravel())
        self.natoms = len(self.mass)
        self.requires_grad = requires_grad
        self.gradient = None
        self.cv = None
        self.type = &#34;default&#34;

    def update_coords(self):
        &#34;&#34;&#34;The coords tensor and ndarray share the same memory.
        Modifications to the tensor will be reflected in the ndarray and vice versa!&#34;&#34;&#34;
        self.coords = torch.from_numpy(self.the_mol.get_sampling_data().coords.ravel())
        self.coords = self.coords.float()
        self.coords.requires_grad = self.requires_grad

    @staticmethod
    def _partial_derivative(
        f: torch.tensor, *args: Tuple[torch.tensor]
    ) -&gt; Tuple[torch.tensor]:
        &#34;&#34;&#34;get partial derivative of arbitrary function from torch.autograd
    
        Args:
            f (torch.tensor): function f(*args) to differentiate
            *args (torch.tensor): variables of f for which derivative is computed
    
        Returns:
            partial_derivatives (Tuple[torch.tensor]): derivatives of f with respect to args
        &#34;&#34;&#34;
        return torch.autograd.grad(f, *args, allow_unused=True)

    def _get_com(self, atoms: Union[int, list]) -&gt; Tuple[torch.tensor, float]:
        &#34;&#34;&#34;get center of mass (com) of group of atoms
        if self.require_grad = True partial derivative with respect to com can be calculated using torch.autograd.grad

        Args:
            atoms (Union[int, list]): atom index or list of atom indices

        Returns:
            com (torch.tensor): Center of Mass
            m_tot(float): Total mass of involved atoms
        &#34;&#34;&#34;
        if hasattr(atoms, &#34;__len__&#34;):
            # compute center of mass for group of atoms
            com = torch.zeros(3, dtype=torch.float)
            for a in atoms:
                a = int(a)
                com += self.coords[3 * a] * self.mass[a]
                com += self.coords[3 * a + 1] * self.mass[a]
                com += self.coords[3 * a + 2] * self.mass[a]

            m_tot = self.mass[atoms].sum()
            com /= m_tot

        else:
            # only one atom
            atom = int(atoms)
            m_tot = self.mass[atom]
            com = torch.tensor(
                [
                    self.coords[3 * atom],
                    self.coords[3 * atom + 1],
                    self.coords[3 * atom + 2],
                ]
            )
        com = com.float()
        com.requires_grad = self.requires_grad

        return com, m_tot

    def _get_atom_weights(
        self, mass_group: float, atoms: Union[int, list]
    ) -&gt; torch.tensor:
        &#34;&#34;&#34;get mass weights of atoms for gradient of group of atoms

        Args:
            mass_group (float): sum of mass of atoms
            atoms (Union[int, list]): atom index or list of atom indices

        Returns:
            coords (torch.tensor): 3*3N array of mass weights of atoms
        &#34;&#34;&#34;
        coords = torch.zeros((3, 3 * self.natoms))
        if hasattr(atoms, &#34;__len__&#34;):
            for a in atoms:
                a = int(a)
                coords[0, 3 * a] = self.mass[a] / mass_group
                coords[1, 3 * a + 1] = self.mass[a] / mass_group
                coords[2, 3 * a + 2] = self.mass[a] / mass_group
        else:
            atoms = int(atoms)
            coords[0, 3 * atoms] = 1.0
            coords[1, 3 * atoms + 1] = 1.0
            coords[2, 3 * atoms + 2] = 1.0

        return coords

    def x(self) -&gt; float:
        &#34;&#34;&#34;use x axis as cv for numerical examples&#34;&#34;&#34;
        self.update_coords()
        if self.requires_grad:
            self.gradient = np.array([1.0, 0.0])
        self.cv = self.coords[0]
        return self.cv

    def y(self) -&gt; float:
        &#34;&#34;&#34;use y axis as cv for numerical examples&#34;&#34;&#34;
        self.update_coords()
        if self.requires_grad:
            self.gradient = np.array([0.0, 1.0])
        self.cv = self.coords[1]
        return self.cv

    def distance(self, cv_def: list) -&gt; float:
        &#34;&#34;&#34;distance between two mass centers in range(0, inf)

        Args:
            cv_def (list):
                distance beteen atoms: [ind0, ind1]
                distance between mass centers: [[ind00, ind01, ...], [ind10, ind11, ...]]

        Returns:
            cv (float): computed distance
        &#34;&#34;&#34;
        if len(cv_def) != 2:
            raise ValueError(
                &#34;CV ERROR: Invalid number of centers in definition of distance!&#34;
            )

        self.update_coords()

        (p1, m0) = self._get_com(cv_def[0])
        (p2, m1) = self._get_com(cv_def[1])

        # get distance
        r12 = p2 - p1
        self.cv = torch.linalg.norm(r12, dtype=torch.float)

        # get forces
        if self.requires_grad:
            # @AH: why don&#39;t you do? Does this not work?
            #            self.gradient = self.partial_derivative(self.cv, self.coords)
            atom_grads = self._partial_derivative(self.cv, (p1, p2))
            self.gradient = torch.matmul(
                atom_grads[0], self._get_atom_weights(m0, cv_def[0])
            )
            self.gradient += torch.matmul(
                atom_grads[1], self._get_atom_weights(m1, cv_def[1])
            )
            self.gradient = self.gradient.numpy()
        
        # AH: this returns (None,), I don&#39;t know why.
        #       self.gradient = torch.autograd.grad(self.cv, self.coords, allow_unused=True)

        return float(self.cv)

    def angle(self, cv_def: list) -&gt; float:
        &#34;&#34;&#34;get angle between three mass centers in range(-pi,pi)

        Args:
            cv_def (list):
                angle between two atoms: [ind0, ind1, ind3]
                angle between centers of mass: [[ind00, ind01, ...], [ind10, ind11, ...], [ind20, ind21, ...]]

        Returns:
            cv (float): computed angle
        &#34;&#34;&#34;
        if len(cv_def) != 3:
            raise ValueError(
                &#34;CV ERROR: Invalid number of centers in definition of angle!&#34;
            )

        self.update_coords()

        (p1, m0) = self._get_com(cv_def[0])
        (p2, m1) = self._get_com(cv_def[1])
        (p3, m2) = self._get_com(cv_def[2])

        # get angle
        q12 = p1 - p2
        q23 = p2 - p3

        q12_n = torch.linalg.norm(q12)
        q23_n = torch.linalg.norm(q23)

        q12_u = q12 / q12_n
        q23_u = q23 / q23_n

        self.cv = torch.arccos(torch.dot(-q12_u, q23_u))

        # get forces
        if self.requires_grad:
            atom_grads = self._partial_derivative(self.cv, (p1, p2, p3))
            self.gradient = torch.matmul(
                atom_grads[0], self._get_atom_weights(m0, cv_def[0])
            )
            self.gradient += torch.matmul(
                atom_grads[1], self._get_atom_weights(m1, cv_def[1])
            )
            self.gradient += torch.matmul(
                atom_grads[2], self._get_atom_weights(m2, cv_def[2])
            )
            self.gradient = self.gradient.numpy()

        return float(self.cv)

    def torsion(self, cv_def: list) -&gt; float:
        &#34;&#34;&#34;torsion angle between four mass centers in range(-pi,pi)

        Args:
            cv_def (list):
                dihedral between atoms: [ind0, ind1, ind2, ind3]
                dihedral between center of mass: [[ind00, ind01, ...],
                                                  [ind10, ind11, ...],
                                                  [ind20, ind21, ...],
                                                  [ind30, ind 31, ...]]

        Returns:
            cv (float): computed torsional angle
        &#34;&#34;&#34;
        if len(cv_def) != 4:
            raise ValueError(
                &#34;CV ERROR: Invalid number of centers in definition of dihedral!&#34;
            )

        self.update_coords()

        (p1, m1) = self._get_com(cv_def[0])
        (p2, m2) = self._get_com(cv_def[1])
        (p3, m3) = self._get_com(cv_def[2])
        (p4, m4) = self._get_com(cv_def[3])

        # get dihedral
        q12 = p2 - p1
        q23 = p3 - p2
        q34 = p4 - p3

        q23_u = q23 / torch.linalg.norm(q23)

        n1 = -q12 - torch.dot(-q12, q23_u) * q23_u
        n2 = q34 - torch.dot(q34, q23_u) * q23_u

        self.cv = torch.atan2(torch.dot(torch.cross(q23_u, n1), n2), torch.dot(n1, n2))

        # get forces
        if self.requires_grad:
            atom_grads = self._partial_derivative(self.cv, (p1, p2, p3, p4))
            self.gradient = torch.matmul(
                atom_grads[0], self._get_atom_weights(m1, cv_def[0])
            )
            self.gradient += torch.matmul(
                atom_grads[1], self._get_atom_weights(m2, cv_def[1])
            )
            self.gradient += torch.matmul(
                atom_grads[2], self._get_atom_weights(m3, cv_def[2])
            )
            self.gradient += torch.matmul(
                atom_grads[3], self._get_atom_weights(m4, cv_def[3])
            )
            self.gradient = self.gradient.numpy()

        return float(self.cv)

    def linear_combination(self, cv_def: list) -&gt; float:
        &#34;&#34;&#34;linear combination of distances, angles or dihedrals between atoms or groups of atoms

        Args:
            cv_dev (list):
                list of distances, angle or torsions with prefactors: [[fac0, [ind00, ind01]],
                                                                       [fac1, [ind10, ind11, ind12]],
                                                                       [fac2, [ind20, ind21, ind22, ind23]],
                                                                       ...]

        Returns:
            cv (float): linear combination of distances/angles/dihedrals
        &#34;&#34;&#34;
        self.update_coords()

        self.lc_contribs = []
        gradient = np.zeros(3 * self.natoms, dtype=float)

        for cv in cv_def:

            if len(cv[1]) == 2:
                x = self.distance(cv[1])

            elif len(cv[1]) == 3:
                x = self.angle(cv[1])

            elif len(cv[1]) == 4:
                x = self.torsion(cv[1])

            else:
                raise ValueError(
                    &#34;CV ERROR: Invalid number of centers in definition of linear combination!&#34;
                )

            self.lc_contribs.append(cv[0] * x)
            if self.requires_grad:
                gradient += cv[0] * self.gradient

        if self.requires_grad:
            self.gradient = gradient

        self.cv = np.asarray(self.lc_contribs).sum()
        return float(self.cv)

    def write_lc_traj(self, out: str = &#34;lc_traj.dat&#34;):
        &#34;&#34;&#34;write out seperate trajectory for contributions to linear combination

        Args:
            our (str): name of output file
        &#34;&#34;&#34;
        with open(out, &#34;a&#34;) as traj_out:
            for lc in self.lc_contribs:
                traj_out.write(&#34;%14.6f\t&#34; % lc)
            traj_out.write(&#34;\n&#34;)

    def coordination_number(self, cv_def: list, r_0: float = 3.0) -&gt; float:
        &#34;&#34;&#34;coordination number between two mass centers in range(0, inf) mapped to range(1,0)

        Args:
            cv_def (list):
                distorted distance beteen atoms: [ind0, ind1]
                distorted distance between mass centers: [[ind00, ind01, ...],
                                                          [ind10, ind11, ...]]

        Returns:
            distorted distance (float): computed distance
        &#34;&#34;&#34;
        self.update_coords()

        if len(cv_def) != 2:
            raise ValueError(
                &#34;CV ERROR: Invalid number of centers in definition of distance!&#34;
            )

        r_0 /= BOHR_to_ANGSTROM

        (p1, m0) = self._get_com(cv_def[0])
        (p2, m1) = self._get_com(cv_def[1])

        # get distance
        r12 = p2 - p1
        d = torch.linalg.norm(r12, dtype=torch.float) / r_0

        self.cv = (1.0 - torch.pow(d, 6)) / (1.0 - torch.pow(d, 12))

        # get forces
        if self.requires_grad:
            atom_grads = self._partial_derivative(self.cv, (p1, p2))
            self.gradient = torch.matmul(
                atom_grads[0], self._get_atom_weights(m0, cv_def[0])
            )
            self.gradient += torch.matmul(
                atom_grads[1], self._get_atom_weights(m1, cv_def[1])
            )
            self.gradient = self.gradient.numpy()

        return float(self.cv)

    def custom_lin_comb(self, cvs: list, **kwargs) -&gt; float:
        &#34;&#34;&#34;custom linear combination of arbitrary functions&#34;&#34;&#34;
        self.update_coords()
        cv = 0.0
        gradient = np.zeros(len(self.gradient))
        for _, cv_def in enumerate(cvs):
            z, dz = self.get_cv(cv_def[0], cv_def[2])
            cv += cv_def[1] * z
            gradient += cv_def[1] * dz

        self.cv = cv
        self.gradient = gradient
        return float(cv)

    def get_cv(self, cv, atoms, **kwargs) -&gt; Tuple[float, np.ndarray]:
        &#34;&#34;&#34;get state of collective variable

        Returns:
           xi (float): value of collective variable
           gradient (np.ndarray) : gradient of collective variable
        &#34;&#34;&#34;
        if cv.lower() == &#34;x&#34;:
            xi = self.x()
            self.type = &#34;2d&#34;
        elif cv.lower() == &#34;y&#34;:
            xi = self.y()
            self.type = &#34;2d&#34;
        elif cv.lower() == &#34;distance&#34;:
            xi = self.distance(atoms)
            self.type = &#34;distance&#34;
        elif cv.lower() == &#34;angle&#34;:
            xi = self.angle(atoms)
            self.type = &#34;angle&#34;
        elif cv.lower() == &#34;torsion&#34;:
            xi = self.torsion(atoms)
            self.type = &#34;angle&#34;
        elif cv.lower() == &#34;lin_comb_dists&#34;:
            xi = self.linear_combination(atoms)
            self.type = &#34;distance&#34;
        elif cv.lower() == &#34;lin_comb_angles&#34;:
            xi = self.linear_combination(atoms)
            self.type = &#34;angle&#34;
        elif cv.lower() == &#34;linear_combination&#34;:
            xi = self.linear_combination(atoms)
            self.type = None
        elif cv.lower() == &#34;coordination_number&#34;:
            xi = self.coordination_number(atoms)
            self.type = None
        elif cv.lower() == &#34;lin_comb_custom&#34;:
            xi = self.custom_lin_comb(atoms)
            self.type = None
        else:
            print(&#34; &gt;&gt;&gt; Error in CV: Unknown coordinate&#34;)
            sys.exit(1)

        if self.requires_grad:
            return xi, self.gradient
        else:
            return xi</code></pre>
</details>
<h3>Methods</h3>
<dl>
<dt id="adaptive_sampling.colvars.colvars.CV.angle"><code class="name flex">
<span>def <span class="ident">angle</span></span>(<span>self, cv_def: list) ‑> float</span>
</code></dt>
<dd>
<div class="desc"><p>get angle between three mass centers in range(-pi,pi)</p>
<h2 id="args">Args</h2>
<p>cv_def (list):
angle between two atoms: [ind0, ind1, ind3]
angle between centers of mass: [[ind00, ind01, &hellip;], [ind10, ind11, &hellip;], [ind20, ind21, &hellip;]]</p>
<h2 id="returns">Returns</h2>
<p>cv (float): computed angle</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def angle(self, cv_def: list) -&gt; float:
    &#34;&#34;&#34;get angle between three mass centers in range(-pi,pi)

    Args:
        cv_def (list):
            angle between two atoms: [ind0, ind1, ind3]
            angle between centers of mass: [[ind00, ind01, ...], [ind10, ind11, ...], [ind20, ind21, ...]]

    Returns:
        cv (float): computed angle
    &#34;&#34;&#34;
    if len(cv_def) != 3:
        raise ValueError(
            &#34;CV ERROR: Invalid number of centers in definition of angle!&#34;
        )

    self.update_coords()

    (p1, m0) = self._get_com(cv_def[0])
    (p2, m1) = self._get_com(cv_def[1])
    (p3, m2) = self._get_com(cv_def[2])

    # get angle
    q12 = p1 - p2
    q23 = p2 - p3

    q12_n = torch.linalg.norm(q12)
    q23_n = torch.linalg.norm(q23)

    q12_u = q12 / q12_n
    q23_u = q23 / q23_n

    self.cv = torch.arccos(torch.dot(-q12_u, q23_u))

    # get forces
    if self.requires_grad:
        atom_grads = self._partial_derivative(self.cv, (p1, p2, p3))
        self.gradient = torch.matmul(
            atom_grads[0], self._get_atom_weights(m0, cv_def[0])
        )
        self.gradient += torch.matmul(
            atom_grads[1], self._get_atom_weights(m1, cv_def[1])
        )
        self.gradient += torch.matmul(
            atom_grads[2], self._get_atom_weights(m2, cv_def[2])
        )
        self.gradient = self.gradient.numpy()

    return float(self.cv)</code></pre>
</details>
</dd>
<dt id="adaptive_sampling.colvars.colvars.CV.coordination_number"><code class="name flex">
<span>def <span class="ident">coordination_number</span></span>(<span>self, cv_def: list, r_0: float = 3.0) ‑> float</span>
</code></dt>
<dd>
<div class="desc"><p>coordination number between two mass centers in range(0, inf) mapped to range(1,0)</p>
<h2 id="args">Args</h2>
<p>cv_def (list):
distorted distance beteen atoms: [ind0, ind1]
distorted distance between mass centers: [[ind00, ind01, &hellip;],
[ind10, ind11, &hellip;]]</p>
<h2 id="returns">Returns</h2>
<p>distorted distance (float): computed distance</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def coordination_number(self, cv_def: list, r_0: float = 3.0) -&gt; float:
    &#34;&#34;&#34;coordination number between two mass centers in range(0, inf) mapped to range(1,0)

    Args:
        cv_def (list):
            distorted distance beteen atoms: [ind0, ind1]
            distorted distance between mass centers: [[ind00, ind01, ...],
                                                      [ind10, ind11, ...]]

    Returns:
        distorted distance (float): computed distance
    &#34;&#34;&#34;
    self.update_coords()

    if len(cv_def) != 2:
        raise ValueError(
            &#34;CV ERROR: Invalid number of centers in definition of distance!&#34;
        )

    r_0 /= BOHR_to_ANGSTROM

    (p1, m0) = self._get_com(cv_def[0])
    (p2, m1) = self._get_com(cv_def[1])

    # get distance
    r12 = p2 - p1
    d = torch.linalg.norm(r12, dtype=torch.float) / r_0

    self.cv = (1.0 - torch.pow(d, 6)) / (1.0 - torch.pow(d, 12))

    # get forces
    if self.requires_grad:
        atom_grads = self._partial_derivative(self.cv, (p1, p2))
        self.gradient = torch.matmul(
            atom_grads[0], self._get_atom_weights(m0, cv_def[0])
        )
        self.gradient += torch.matmul(
            atom_grads[1], self._get_atom_weights(m1, cv_def[1])
        )
        self.gradient = self.gradient.numpy()

    return float(self.cv)</code></pre>
</details>
</dd>
<dt id="adaptive_sampling.colvars.colvars.CV.custom_lin_comb"><code class="name flex">
<span>def <span class="ident">custom_lin_comb</span></span>(<span>self, cvs: list, **kwargs) ‑> float</span>
</code></dt>
<dd>
<div class="desc"><p>custom linear combination of arbitrary functions</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def custom_lin_comb(self, cvs: list, **kwargs) -&gt; float:
    &#34;&#34;&#34;custom linear combination of arbitrary functions&#34;&#34;&#34;
    self.update_coords()
    cv = 0.0
    gradient = np.zeros(len(self.gradient))
    for _, cv_def in enumerate(cvs):
        z, dz = self.get_cv(cv_def[0], cv_def[2])
        cv += cv_def[1] * z
        gradient += cv_def[1] * dz

    self.cv = cv
    self.gradient = gradient
    return float(cv)</code></pre>
</details>
</dd>
<dt id="adaptive_sampling.colvars.colvars.CV.distance"><code class="name flex">
<span>def <span class="ident">distance</span></span>(<span>self, cv_def: list) ‑> float</span>
</code></dt>
<dd>
<div class="desc"><p>distance between two mass centers in range(0, inf)</p>
<h2 id="args">Args</h2>
<p>cv_def (list):
distance beteen atoms: [ind0, ind1]
distance between mass centers: [[ind00, ind01, &hellip;], [ind10, ind11, &hellip;]]</p>
<h2 id="returns">Returns</h2>
<p>cv (float): computed distance</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def distance(self, cv_def: list) -&gt; float:
    &#34;&#34;&#34;distance between two mass centers in range(0, inf)

    Args:
        cv_def (list):
            distance beteen atoms: [ind0, ind1]
            distance between mass centers: [[ind00, ind01, ...], [ind10, ind11, ...]]

    Returns:
        cv (float): computed distance
    &#34;&#34;&#34;
    if len(cv_def) != 2:
        raise ValueError(
            &#34;CV ERROR: Invalid number of centers in definition of distance!&#34;
        )

    self.update_coords()

    (p1, m0) = self._get_com(cv_def[0])
    (p2, m1) = self._get_com(cv_def[1])

    # get distance
    r12 = p2 - p1
    self.cv = torch.linalg.norm(r12, dtype=torch.float)

    # get forces
    if self.requires_grad:
        # @AH: why don&#39;t you do? Does this not work?
        #            self.gradient = self.partial_derivative(self.cv, self.coords)
        atom_grads = self._partial_derivative(self.cv, (p1, p2))
        self.gradient = torch.matmul(
            atom_grads[0], self._get_atom_weights(m0, cv_def[0])
        )
        self.gradient += torch.matmul(
            atom_grads[1], self._get_atom_weights(m1, cv_def[1])
        )
        self.gradient = self.gradient.numpy()
    
    # AH: this returns (None,), I don&#39;t know why.
    #       self.gradient = torch.autograd.grad(self.cv, self.coords, allow_unused=True)

    return float(self.cv)</code></pre>
</details>
</dd>
<dt id="adaptive_sampling.colvars.colvars.CV.get_cv"><code class="name flex">
<span>def <span class="ident">get_cv</span></span>(<span>self, cv, atoms, **kwargs) ‑> Tuple[float, numpy.ndarray]</span>
</code></dt>
<dd>
<div class="desc"><p>get state of collective variable</p>
<h2 id="returns">Returns</h2>
<p>xi (float): value of collective variable
gradient (np.ndarray) : gradient of collective variable</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_cv(self, cv, atoms, **kwargs) -&gt; Tuple[float, np.ndarray]:
    &#34;&#34;&#34;get state of collective variable

    Returns:
       xi (float): value of collective variable
       gradient (np.ndarray) : gradient of collective variable
    &#34;&#34;&#34;
    if cv.lower() == &#34;x&#34;:
        xi = self.x()
        self.type = &#34;2d&#34;
    elif cv.lower() == &#34;y&#34;:
        xi = self.y()
        self.type = &#34;2d&#34;
    elif cv.lower() == &#34;distance&#34;:
        xi = self.distance(atoms)
        self.type = &#34;distance&#34;
    elif cv.lower() == &#34;angle&#34;:
        xi = self.angle(atoms)
        self.type = &#34;angle&#34;
    elif cv.lower() == &#34;torsion&#34;:
        xi = self.torsion(atoms)
        self.type = &#34;angle&#34;
    elif cv.lower() == &#34;lin_comb_dists&#34;:
        xi = self.linear_combination(atoms)
        self.type = &#34;distance&#34;
    elif cv.lower() == &#34;lin_comb_angles&#34;:
        xi = self.linear_combination(atoms)
        self.type = &#34;angle&#34;
    elif cv.lower() == &#34;linear_combination&#34;:
        xi = self.linear_combination(atoms)
        self.type = None
    elif cv.lower() == &#34;coordination_number&#34;:
        xi = self.coordination_number(atoms)
        self.type = None
    elif cv.lower() == &#34;lin_comb_custom&#34;:
        xi = self.custom_lin_comb(atoms)
        self.type = None
    else:
        print(&#34; &gt;&gt;&gt; Error in CV: Unknown coordinate&#34;)
        sys.exit(1)

    if self.requires_grad:
        return xi, self.gradient
    else:
        return xi</code></pre>
</details>
</dd>
<dt id="adaptive_sampling.colvars.colvars.CV.linear_combination"><code class="name flex">
<span>def <span class="ident">linear_combination</span></span>(<span>self, cv_def: list) ‑> float</span>
</code></dt>
<dd>
<div class="desc"><p>linear combination of distances, angles or dihedrals between atoms or groups of atoms</p>
<h2 id="args">Args</h2>
<p>cv_dev (list):
list of distances, angle or torsions with prefactors: [[fac0, [ind00, ind01]],
[fac1, [ind10, ind11, ind12]],
[fac2, [ind20, ind21, ind22, ind23]],
&hellip;]</p>
<h2 id="returns">Returns</h2>
<p>cv (float): linear combination of distances/angles/dihedrals</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def linear_combination(self, cv_def: list) -&gt; float:
    &#34;&#34;&#34;linear combination of distances, angles or dihedrals between atoms or groups of atoms

    Args:
        cv_dev (list):
            list of distances, angle or torsions with prefactors: [[fac0, [ind00, ind01]],
                                                                   [fac1, [ind10, ind11, ind12]],
                                                                   [fac2, [ind20, ind21, ind22, ind23]],
                                                                   ...]

    Returns:
        cv (float): linear combination of distances/angles/dihedrals
    &#34;&#34;&#34;
    self.update_coords()

    self.lc_contribs = []
    gradient = np.zeros(3 * self.natoms, dtype=float)

    for cv in cv_def:

        if len(cv[1]) == 2:
            x = self.distance(cv[1])

        elif len(cv[1]) == 3:
            x = self.angle(cv[1])

        elif len(cv[1]) == 4:
            x = self.torsion(cv[1])

        else:
            raise ValueError(
                &#34;CV ERROR: Invalid number of centers in definition of linear combination!&#34;
            )

        self.lc_contribs.append(cv[0] * x)
        if self.requires_grad:
            gradient += cv[0] * self.gradient

    if self.requires_grad:
        self.gradient = gradient

    self.cv = np.asarray(self.lc_contribs).sum()
    return float(self.cv)</code></pre>
</details>
</dd>
<dt id="adaptive_sampling.colvars.colvars.CV.torsion"><code class="name flex">
<span>def <span class="ident">torsion</span></span>(<span>self, cv_def: list) ‑> float</span>
</code></dt>
<dd>
<div class="desc"><p>torsion angle between four mass centers in range(-pi,pi)</p>
<h2 id="args">Args</h2>
<p>cv_def (list):
dihedral between atoms: [ind0, ind1, ind2, ind3]
dihedral between center of mass: [[ind00, ind01, &hellip;],
[ind10, ind11, &hellip;],
[ind20, ind21, &hellip;],
[ind30, ind 31, &hellip;]]</p>
<h2 id="returns">Returns</h2>
<p>cv (float): computed torsional angle</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def torsion(self, cv_def: list) -&gt; float:
    &#34;&#34;&#34;torsion angle between four mass centers in range(-pi,pi)

    Args:
        cv_def (list):
            dihedral between atoms: [ind0, ind1, ind2, ind3]
            dihedral between center of mass: [[ind00, ind01, ...],
                                              [ind10, ind11, ...],
                                              [ind20, ind21, ...],
                                              [ind30, ind 31, ...]]

    Returns:
        cv (float): computed torsional angle
    &#34;&#34;&#34;
    if len(cv_def) != 4:
        raise ValueError(
            &#34;CV ERROR: Invalid number of centers in definition of dihedral!&#34;
        )

    self.update_coords()

    (p1, m1) = self._get_com(cv_def[0])
    (p2, m2) = self._get_com(cv_def[1])
    (p3, m3) = self._get_com(cv_def[2])
    (p4, m4) = self._get_com(cv_def[3])

    # get dihedral
    q12 = p2 - p1
    q23 = p3 - p2
    q34 = p4 - p3

    q23_u = q23 / torch.linalg.norm(q23)

    n1 = -q12 - torch.dot(-q12, q23_u) * q23_u
    n2 = q34 - torch.dot(q34, q23_u) * q23_u

    self.cv = torch.atan2(torch.dot(torch.cross(q23_u, n1), n2), torch.dot(n1, n2))

    # get forces
    if self.requires_grad:
        atom_grads = self._partial_derivative(self.cv, (p1, p2, p3, p4))
        self.gradient = torch.matmul(
            atom_grads[0], self._get_atom_weights(m1, cv_def[0])
        )
        self.gradient += torch.matmul(
            atom_grads[1], self._get_atom_weights(m2, cv_def[1])
        )
        self.gradient += torch.matmul(
            atom_grads[2], self._get_atom_weights(m3, cv_def[2])
        )
        self.gradient += torch.matmul(
            atom_grads[3], self._get_atom_weights(m4, cv_def[3])
        )
        self.gradient = self.gradient.numpy()

    return float(self.cv)</code></pre>
</details>
</dd>
<dt id="adaptive_sampling.colvars.colvars.CV.update_coords"><code class="name flex">
<span>def <span class="ident">update_coords</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>The coords tensor and ndarray share the same memory.
Modifications to the tensor will be reflected in the ndarray and vice versa!</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def update_coords(self):
    &#34;&#34;&#34;The coords tensor and ndarray share the same memory.
    Modifications to the tensor will be reflected in the ndarray and vice versa!&#34;&#34;&#34;
    self.coords = torch.from_numpy(self.the_mol.get_sampling_data().coords.ravel())
    self.coords = self.coords.float()
    self.coords.requires_grad = self.requires_grad</code></pre>
</details>
</dd>
<dt id="adaptive_sampling.colvars.colvars.CV.write_lc_traj"><code class="name flex">
<span>def <span class="ident">write_lc_traj</span></span>(<span>self, out: str = 'lc_traj.dat')</span>
</code></dt>
<dd>
<div class="desc"><p>write out seperate trajectory for contributions to linear combination</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>our</code></strong> :&ensp;<code>str</code></dt>
<dd>name of output file</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def write_lc_traj(self, out: str = &#34;lc_traj.dat&#34;):
    &#34;&#34;&#34;write out seperate trajectory for contributions to linear combination

    Args:
        our (str): name of output file
    &#34;&#34;&#34;
    with open(out, &#34;a&#34;) as traj_out:
        for lc in self.lc_contribs:
            traj_out.write(&#34;%14.6f\t&#34; % lc)
        traj_out.write(&#34;\n&#34;)</code></pre>
</details>
</dd>
<dt id="adaptive_sampling.colvars.colvars.CV.x"><code class="name flex">
<span>def <span class="ident">x</span></span>(<span>self) ‑> float</span>
</code></dt>
<dd>
<div class="desc"><p>use x axis as cv for numerical examples</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def x(self) -&gt; float:
    &#34;&#34;&#34;use x axis as cv for numerical examples&#34;&#34;&#34;
    self.update_coords()
    if self.requires_grad:
        self.gradient = np.array([1.0, 0.0])
    self.cv = self.coords[0]
    return self.cv</code></pre>
</details>
</dd>
<dt id="adaptive_sampling.colvars.colvars.CV.y"><code class="name flex">
<span>def <span class="ident">y</span></span>(<span>self) ‑> float</span>
</code></dt>
<dd>
<div class="desc"><p>use y axis as cv for numerical examples</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def y(self) -&gt; float:
    &#34;&#34;&#34;use y axis as cv for numerical examples&#34;&#34;&#34;
    self.update_coords()
    if self.requires_grad:
        self.gradient = np.array([0.0, 1.0])
    self.cv = self.coords[1]
    return self.cv</code></pre>
</details>
</dd>
</dl>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="adaptive_sampling.colvars" href="index.html">adaptive_sampling.colvars</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="adaptive_sampling.colvars.colvars.CV" href="#adaptive_sampling.colvars.colvars.CV">CV</a></code></h4>
<ul class="two-column">
<li><code><a title="adaptive_sampling.colvars.colvars.CV.angle" href="#adaptive_sampling.colvars.colvars.CV.angle">angle</a></code></li>
<li><code><a title="adaptive_sampling.colvars.colvars.CV.coordination_number" href="#adaptive_sampling.colvars.colvars.CV.coordination_number">coordination_number</a></code></li>
<li><code><a title="adaptive_sampling.colvars.colvars.CV.custom_lin_comb" href="#adaptive_sampling.colvars.colvars.CV.custom_lin_comb">custom_lin_comb</a></code></li>
<li><code><a title="adaptive_sampling.colvars.colvars.CV.distance" href="#adaptive_sampling.colvars.colvars.CV.distance">distance</a></code></li>
<li><code><a title="adaptive_sampling.colvars.colvars.CV.get_cv" href="#adaptive_sampling.colvars.colvars.CV.get_cv">get_cv</a></code></li>
<li><code><a title="adaptive_sampling.colvars.colvars.CV.linear_combination" href="#adaptive_sampling.colvars.colvars.CV.linear_combination">linear_combination</a></code></li>
<li><code><a title="adaptive_sampling.colvars.colvars.CV.torsion" href="#adaptive_sampling.colvars.colvars.CV.torsion">torsion</a></code></li>
<li><code><a title="adaptive_sampling.colvars.colvars.CV.update_coords" href="#adaptive_sampling.colvars.colvars.CV.update_coords">update_coords</a></code></li>
<li><code><a title="adaptive_sampling.colvars.colvars.CV.write_lc_traj" href="#adaptive_sampling.colvars.colvars.CV.write_lc_traj">write_lc_traj</a></code></li>
<li><code><a title="adaptive_sampling.colvars.colvars.CV.x" href="#adaptive_sampling.colvars.colvars.CV.x">x</a></code></li>
<li><code><a title="adaptive_sampling.colvars.colvars.CV.y" href="#adaptive_sampling.colvars.colvars.CV.y">y</a></code></li>
</ul>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc" title="pdoc: Python API documentation generator"><cite>pdoc</cite> 0.10.0</a>.</p>
</footer>
</body>
</html>